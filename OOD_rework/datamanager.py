# -*- coding: utf-8 -*-
"""
Created on Mon Feb 11 14:51:49 2019

DataManager classes for the Balance rogue-like RPG

This family of classes contains the logic of the game. Every
 functionality is expected to exist as a DataManager that responds to
 specific messages by modifying the game state passed in the game_data
 variable and then returning the data back to the calling View.
 
Only DataManagers can call the GameData methods. DMs contain the logic
 of the game. All functionality is implemented by a DM. DMs answer to
 messages defined in themselves or their extensions, which are the
 complete list of actions that can be executed on (any piece of) the
 game data by the manager. Messages can be generated by the currently
 executing DM so that a chain occurs behind the scenes after a View
 sends a command, but the View never knows about this. Just as Views
 are separated from one another by the main instance, DMs are separate,
 do not cross-execute, and only return to their View when there are no
 messages left in their queue.
 
DMs contain a dict of the {command:messages} that they respond to.
Must be easily extendable!
 
Emergent behavior is possible when all activities are available to more
 beings and if a completely persistent world is implemented. 
 Example: with "building", "trading", random travelling creatures,
 village design, and "long term goals" (allowing areas to develop in
 the absence of the player) it is possible for a local human to barter
 food for building materials with passing dwarf traders, and then to
 build a house over a long period of time. If there are more humans a
 village may emerge, and further modules may increase the number and
 diversity of persisting local beings. Doesn't this delayed execution
 mean that there muct be some cross-talk between managers? Maybe a
 global message queue with pending actions added once to each manager's
 call (telling the manager to do things that the player didn't ask for
 in the current view)?

@author: IvanPopov
"""
END_GAME = 'end game'
GET_DEFAULT_VIEW = 'get default view'
GET_CHARACTER_CREATION_VIEW = 'get default view'
GET_LOAD_GAME_VIEW = 'get load game view'


class DataManager:
    _view_calls = {}
    
    def __init__(self,personal_message=''):
        self._callsign = ''
        self._direct_links = {}
        self._tasks = {}
        if personal_message:
            self._post_init()
            if self._callsign == '':
                raise ValueError(
                        'Please implement a unique callsign in _post_init()!'
                        )
            DataManager._view_calls[self._callsign] = \
                personal_message
    
    def update_data(self,*,data={},command=''):
        """
        Execute commands until queue is empty.
        """
        if command in DataManager._view_calls:
            return DataManager._view_calls[command]
        if command in self._direct_links:
            return self._direct_links[command]
        if command in self._tasks:
            return self._tasks[command](data)
        else:
            return self._unknown_command()
            
    def _post_init(self):
        """
        Subclasses need to override this!
        
        1) (required) Set a unique calling character (aka callsign).
        2) (optional) Build the dm's _direct_links dict that sends for
            other views without them being registered in the
            _view_calls dict. This is used for chains of single use
            views like game startup or quests.
        3) (optional) Build the dm's _tasks dictionary of commands
            and methods
        """
        self._callsign = ''
        #self._direct_links = {}
        #self._tasks = {}
            
    def _unknown_command(self):
        """
        Subclasses need to override this to define the view's reaction
        to an unknown command!
        """
        return END_GAME
    

class StarterManager(DataManager):
    """
    Creates the player character and the initial game data,
    or loads an existing set of data from file,
    and put them in the received variable.
    """
            
    def _post_init(self):
        self._callsign = ' '
        self._direct_links = {'n':GET_CHARACTER_CREATION_VIEW,
                              'l':GET_LOAD_GAME_VIEW}
        
    def _unknown_command(self):
        return ''
    
class EmptyManager:
    
    def __init__(self):
        raise NotImplementedError